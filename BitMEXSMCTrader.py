# -*- coding: utf-8 -*-
"""CompactBot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G-0INX6Sh71JGXK0Ve1ZT8BENMvngrPs
"""

#

# -*- coding: utf-8 -*-
import asyncio
import json
import logging
import os
import threading
import time
import telebot
import pytz
from datetime import datetime, timedelta
from queue import Queue
import sys
import bitmex
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import pandas as pd
from dotenv import load_dotenv
import yfinance as yf
from BitMEXAPI import BitMEXTestAPI
# Load .env file
load_dotenv()


# Set the correct time zone
utc_now = datetime.utcnow()
sast = pytz.timezone('Africa/Johannesburg')
sast_now = utc_now.replace(tzinfo=pytz.utc).astimezone(sast)

class SMC:
    def __init__(self, api_key="", api_secret="", test=True, symbol="SOL-USD",
                 timeframe="15m", risk_per_trade=0.02, lookback_periods=100):
        """
        Initialize the SMC trading class
        """
        self.api_key = api_key
        self.api_secret = api_secret
        self.test = test
        self.symbol = symbol
        self.timeframe = timeframe
        self.risk_per_trade = risk_per_trade
        self.lookback_periods = lookback_periods

        # Initialize BitMEX API client
        self.api = BitMEXTestAPI(
            api_key=self.api_key,
            api_secret=self.api_secret,
            test=self.test
        )

        # Trading state
        self.initial_balance = 0
        self.current_balance = 0
        self.df = pd.DataFrame()
        self.in_trade = False
        self.entry_price = 0
        self.stop_loss = 0
        self.take_profit = 0
        self.position_size = 0
        self.trade_type = None
        self.trades = []
        self.equity_curve = []

        logger.info(f"BitMEXLiveTrader initialized for {symbol} on {timeframe} timeframe")
    def get_market_data(self):
        """
        Fetch market data from BitMEX API or fallback to yfinance
        """
        try:
            print(f"Fetching {self.symbol} market data from BitMEX")
            data = self.api.get_candle(
                symbol=self.symbol,
                timeframe=self.timeframe
            )
            df = pd.DataFrame(data)
            print(f"Retrieved {len(df)} candles from BitMEX")
            self.df = df
            # Normalize column names to lowercase
            self.df.columns = [col.lower() for col in self.df.columns]
            print(f"BitMEX columns: {self.df.columns.tolist()}")
            # Add columns for SMC analysis
            self.df['higher_high'] = False
            self.df['lower_low'] = False
            self.df['bos_up'] = False
            self.df['bos_down'] = False
            self.df['choch_up'] = False
            self.df['choch_down'] = False
            self.df['bullish_fvg'] = False
            self.df['bearish_fvg'] = False
            return df

        except Exception as e:
            print(f"Failed to get data from BitMEX API: {str(e)}. Falling back to yfinance.")

            # Fix ticker symbol for yfinance
            crypto_ticker = self.symbol.replace('USD', '-USD')  # Ensure SOLUSD format
            if not crypto_ticker.endswith('USD'):
                crypto_ticker += 'USD'  # Ensure it ends with USD

            sast_now = get_sast_time()
            end_date = sast_now
            start_date = end_date - timedelta(days=7)

            data = yf.download(
                crypto_ticker,
                start=start_date.strftime('%Y-%m-%d'),
                end=end_date.strftime('%Y-%m-%d'),
                interval=self.timeframe
            )

            print(f"Retrieved {len(data)} candles from yfinance")
            self.df = data
            if not data.empty:
                # Handle potential MultiIndex from yfinance
                if isinstance(self.df.columns, pd.MultiIndex):
                    print(f"MultiIndex detected: {self.df.columns.tolist()}")
                    # Flatten MultiIndex to just the second level (e.g., 'open', 'high', etc.)
                    self.df.columns = [col[0].lower() if isinstance(col, tuple) else col.lower()
                                     for col in self.df.columns]
                else:
                    # Simple Index, just convert to lowercase
                    self.df.columns = [col.lower() for col in self.df.columns]

                print(f"Normalized yfinance columns: {self.df.columns.tolist()}")

                # Verify required columns exist
                required_columns = ['open', 'high', 'low', 'close']
                missing_columns = [col for col in required_columns if col not in self.df.columns]
                if missing_columns:
                    print(f"Warning: Missing required columns: {missing_columns}")
                    return self.df  # Return early if critical columns are missing

                # Add columns for SMC analysis
                self.df['higher_high'] = False
                self.df['lower_low'] = False
                self.df['bos_up'] = False
                self.df['bos_down'] = False
                self.df['choch_up'] = False
                self.df['choch_down'] = False
                self.df['bullish_fvg'] = False
                self.df['bearish_fvg'] = False
            else:
                print("No data retrieved from yfinance")
            return data
    def identify_structure(self):
        """Identify market structure including highs, lows, BOS and CHoCH"""
        logger.info("Identifying market structure")
        print("Identifying market structure")
        df = self.df

        # Identify Higher Highs and Lower Lows (using a 5-candle lookback)
        window = 5
        for i in range(window, len(df)):
            # Higher High
            if df.iloc[i]['high'] > max(df.iloc[i-window:i]['high']):
                df.loc[df.index[i], 'higher_high'] = True

            # Lower Low
            if df.iloc[i]['low'] < min(df.iloc[i-window:i]['low']):
                df.loc[df.index[i], 'lower_low'] = True

        # Identify Break of Structure (BOS)
        prev_structure_high = df.iloc[0]['high']
        prev_structure_low = df.iloc[0]['low']
        structure_points_high = []
        structure_points_low = []

        for i in range(1, len(df)):
            current_high = df.iloc[i]['high']
            current_low = df.iloc[i]['low']

            # Track significant structure points
            if df.iloc[i]['higher_high']:
                structure_points_high.append((i, current_high))

            if df.iloc[i]['lower_low']:
                structure_points_low.append((i, current_low))

            # BOS Up: Price breaks above recent structure high
            if len(structure_points_high) >= 2:
                last_high_idx, last_high = structure_points_high[-1]
                prev_high_idx, prev_high = structure_points_high[-2]

                if current_low > prev_high and i > last_high_idx + 1:
                    df.loc[df.index[i], 'bos_up'] = True
                    #logger.info(f"Bullish BOS detected at index {i}, price: {current_low}")
                    print(f"Bullish BOS detected at index {i}, price: {current_low}")

            # BOS Down: Price breaks below recent structure low
            if len(structure_points_low) >= 2:
                last_low_idx, last_low = structure_points_low[-1]
                prev_low_idx, prev_low = structure_points_low[-2]

                if current_high < prev_low and i > last_low_idx + 1:
                    df.loc[df.index[i], 'bos_down'] = True
                   # logger.info(f"Bearish BOS detected at index {i}, price: {current_high}")
                    print(f"Bearish BOS detected at index {i}, price: {current_high}")

        # Identify Change of Character (CHoCH)
        for i in range(window+1, len(df)):
            # Bullish CHoCH: After BOS up, creates higher low
            if df.iloc[i-1]['bos_up']:
                recent_lows = df.iloc[i-window:i]['low'].tolist()
                if min(recent_lows[:-1]) < recent_lows[-1]:
                    df.loc[df.index[i], 'choch_up'] = True
                    #logger.info(f"Bullish CHoCH detected at index {i},  price: {current_high}")
                    print(f"Bullish CHoCH detected at index {i},  price: {current_high}")

            # Bearish CHoCH: After BOS down, creates lower high
            if df.iloc[i-1]['bos_down']:
                recent_highs = df.iloc[i-window:i]['high'].tolist()
                if max(recent_highs[:-1]) > recent_highs[-1]:
                    df.loc[df.index[i], 'choch_down'] = True
                    #logger.info(f"Bearish CHoCH detected at index {i},  price: {current_high}")
                    print(f"Bearish CHoCH detected at index {i}")
        logger.info("End of Identifying market structure")
        return df

    def identify_fvg(self):
        """Identify Fair Value Gaps (FVGs)"""
        logger.info("Identifying Fair Value Gaps")
        print("Identifying Fair Value Gaps")
        df = self.df

        # Create separate columns for FVG values to avoid tuple storage issues
        if 'bullish_fvg_low' not in df.columns:
            df['bullish_fvg_low'] = np.nan
            df['bullish_fvg_high'] = np.nan
            df['bullish_fvg_sl_index'] = np.nan

        if 'bearish_fvg_low' not in df.columns:
            df['bearish_fvg_low'] = np.nan
            df['bearish_fvg_high'] = np.nan
            df['bearish_fvg_sl_index'] = np.nan

        # Add mitigation tracking columns
        if 'bullish_fvg_mitigated' not in df.columns:
            df['bullish_fvg_mitigated'] = False

        if 'bearish_fvg_mitigated' not in df.columns:
            df['bearish_fvg_mitigated'] = False

        for i in range(2, len(df)):
            # Bullish FVG: Previous candle's low > Current candle's high
            if df.iloc[i-2]['low'] > df.iloc[i]['high']:
                # Check Gann Box (0-0.5 range for bullish FVGs)
                high_point = df.iloc[i-2]['high']
                low_point = df.iloc[i]['low']
                price_range = high_point - low_point
                fvg_low = df.iloc[i]['high']
                fvg_high = df.iloc[i-2]['low']

                # Calculate relative position in Gann Box (0 to 1)
                if price_range > 0:
                    relative_pos = (fvg_high - low_point) / price_range

                    # Only mark valid FVGs within 0-0.5 Gann range
                    if 0 <= relative_pos <= 0.5:
                        df.loc[df.index[i], 'bullish_fvg'] = True
                        # Store FVG values in separate columns
                        df.loc[df.index[i], 'bullish_fvg_low'] = fvg_low
                        df.loc[df.index[i], 'bullish_fvg_high'] = fvg_high
                        df.loc[df.index[i], 'bullish_fvg_sl_index'] = i

                        #logger.info(f"Bullish FVG detected at index {i}, range: {fvg_low}-{fvg_high}")
                        print(f"Bullish FVG detected at index {i}, range: {fvg_low}-{fvg_high}")

            # Bearish FVG: Previous candle's high < Current candle's low
            if df.iloc[i-2]['high'] < df.iloc[i]['low']:
                # Check Gann Box (0.5-1 range for bearish FVGs)
                high_point = df.iloc[i]['high']
                low_point = df.iloc[i-2]['low']
                price_range = high_point - low_point
                fvg_low = df.iloc[i-2]['high']
                fvg_high = df.iloc[i]['low']

                # Calculate relative position in Gann Box (0 to 1)
                if price_range > 0:
                    relative_pos = (fvg_high - low_point) / price_range

                    # Only mark valid FVGs within 0.5-1 Gann range
                    if 0.5 <= relative_pos <= 1:
                        df.loc[df.index[i], 'bearish_fvg'] = True
                        # Store FVG values in separate columns
                        df.loc[df.index[i], 'bearish_fvg_low'] = fvg_low
                        df.loc[df.index[i], 'bearish_fvg_high'] = fvg_high
                        df.loc[df.index[i], 'bearish_fvg_sl_index'] = i

                        #logger.info(f"Bearish FVG detected at index {i}, range: {fvg_low}-{fvg_high}")
                        print(f"Bearish FVG detected at index {i}, range: {fvg_low}-{fvg_high}")
        logger.info("End of Identifying Fair Value Gaps")
        return df

    def check_fvg_mitigation(self, current_idx):
        """Check if any previously identified FVGs have been mitigated"""
        #logger.info("Check if any previously identified FVGs have been mitigated")
        df = self.df

        # Loop through all previous candles
        for i in range(current_idx):
            # Check if the candle had a bullish FVG
            if df.iloc[i].get('bullish_fvg', False) and pd.notna(df.iloc[i].get('bullish_fvg_low')):
                fvg_low = df.iloc[i]['bullish_fvg_low']
                fvg_high = df.iloc[i]['bullish_fvg_high']

                # Check if price revisited the FVG area
                for j in range(i+1, current_idx+1):
                    if df.iloc[j]['low'] <= fvg_high and df.iloc[j]['high'] >= fvg_low:
                        # FVG has been mitigated
                        df.loc[df.index[i], 'bullish_fvg_mitigated'] = True
                        #logger.info(f"Bullish FVG at index {i} has been mitigated at index {j}")
                        print(f"Bullish FVG at index {i} has been mitigated at index {j}")
                        break

            # Check if the candle had a bearish FVG
            if df.iloc[i].get('bearish_fvg', False) and pd.notna(df.iloc[i].get('bearish_fvg_low')):
                fvg_low = df.iloc[i]['bearish_fvg_low']
                fvg_high = df.iloc[i]['bearish_fvg_high']

                # Check if price revisited the FVG area
                for j in range(i+1, current_idx+1):
                    if df.iloc[j]['low'] <= fvg_high and df.iloc[j]['high'] >= fvg_low:
                        # FVG has been mitigated
                        df.loc[df.index[i], 'bearish_fvg_mitigated'] = True
                        #logger.info(f"Bearish FVG at index {i} has been mitigated at index {j}")
                        print(f"Bearish FVG at index {i} has been mitigated at index {j}")
                        break

        return df

    def execute_trades(self):
        """Execute trades based on SMC signals"""
        logger.info("Starting trade execution backtesting")
        print("Starting trade execution backtesting")
        df = self.df

        # Iterate through each candle for backtesting
        for i in range(5, len(df)):
            current_price = df.iloc[i]['close']

            # Check if we're in a trade
            if self.in_trade:
                # Check if stop loss hit
                if (self.trade_type == 'long' and df.iloc[i]['low'] <= self.stop_loss) or \
                   (self.trade_type == 'short' and df.iloc[i]['high'] >= self.stop_loss):
                    #

                    # Stop loss hit
                     self.execute_signal({
                     'price': self.take_profit,  # Use the take_profit price as the exit price
                     'take_profit': self.take_profit,
                     'action': "exit",
                     'reason': 'takeprofit',
                       })

                     #self.execute_signal(signal)
                     logger.info("Stop loss hit âŽâŽâŽ")


                # Check if take profit hit
                elif (self.trade_type == 'long' and df.iloc[i]['high'] >= self.take_profit) or \
                     (self.trade_type == 'short' and df.iloc[i]['low'] <= self.take_profit):
                    # Take profit hit
                    self.execute_signal({
                               'take_profit': self.take_profit,
                               'price': self.take_profit,
                                'action': "exit",
                                'reason': 'takeprofit',
                               })
                    #self.execute_signal(signal)
                    logger.info("Take profit hit ðŸ’²âœ”ï¸âœ”ï¸")


            else:
                # Update FVG mitigation status
                self.check_fvg_mitigation(i)

                # Check for new trade setups

                # Bullish setup: BOS up + CHoCH up + unmitigated bullish FVG
                if df.iloc[i-1]['bos_up'] and df.iloc[i]['choch_up']:
                    # Look back for unmitigated bullish FVGs
                    for j in range(i-10, i):
                        if j >= 0 and df.iloc[j].get('bullish_fvg', False) and not df.iloc[j].get('bullish_fvg_mitigated', False):
                            fvg_low = df.iloc[j]['bullish_fvg_low']
                            fvg_high = df.iloc[j]['bullish_fvg_high']
                            sl_idx = int(df.iloc[j]['bullish_fvg_sl_index'])

                            # Check if price is near the FVG
                            if fvg_low <= current_price <= fvg_high:
                                # Setup stop loss at the low of the FVG-forming candle
                                stop_loss = df.iloc[sl_idx]['low']

                                # Find recent structure low for take profit
                                recent_lows = df.iloc[i-20:i]['low'].tolist()
                                min_idx = recent_lows.index(min(recent_lows))
                                take_profit = df.iloc[i-20+min_idx]['low']

                                stop_loss = df.iloc[sl_idx]['low']
                                risk = current_price - stop_loss
                                take_profit = current_price + (risk * 2)  # 2:1 risk-reward
                                signal = {
                                    'action': 'entry',
                                    'side': 'long',
                                    'price': current_price,
                                    'stop_loss': stop_loss,
                                    'take_profit': take_profit
                                }
                                # Enter long trade
                                self.execute_signal(signal)
                                logger.info("Enter longðŸ”µ(Buy) ðŸ“ˆðŸ“ˆðŸ“ˆ trade ðŸƒðŸƒðŸƒ")

                                break

                # Bearish setup: BOS down + CHoCH down + unmitigated bearish FVG
                if df.iloc[i-1]['bos_down'] and df.iloc[i]['choch_down']:
                    # Look back for unmitigated bearish FVGs
                    for j in range(i-10, i):
                        if j >= 0 and df.iloc[j].get('bearish_fvg', False) and not df.iloc[j].get('bearish_fvg_mitigated', False):
                            fvg_low = df.iloc[j]['bearish_fvg_low']
                            fvg_high = df.iloc[j]['bearish_fvg_high']
                            sl_idx = int(df.iloc[j]['bearish_fvg_sl_index'])

                            # Check if price is near the FVG
                            if fvg_low <= current_price <= fvg_high:
                                # Setup stop loss at the high of the FVG-forming candle
                                stop_loss = df.iloc[sl_idx]['high']

                                # Find recent structure high for take profit
                                recent_highs = df.iloc[i-20:i]['high'].tolist()
                                max_idx = recent_highs.index(max(recent_highs))
                                take_profit = df.iloc[i-20+max_idx]['high']

                                # Enter short trade
                                stop_loss = df.iloc[sl_idx]['high']
                                risk = stop_loss - current_price
                                take_profit = current_price - (risk * 2)  # 2:1 risk-reward

                                signal = {
                                    'action': 'entry',
                                    'side': 'short',
                                    'price': current_price,
                                    'stop_loss': stop_loss,
                                    'take_profit': take_profit
                                }
                                self.execute_signal(signal)
                                logger.info("Enter shortðŸ”´(Sell)ðŸ“‰ðŸ“‰ðŸ“‰ trade ðŸ»ðŸ»ðŸ»")
                                break

        # Close any open trade at the end of testing
        #if self.in_trade:
            # Take profit hit
             #signal = {
                              # 'price': self.df.iloc[-1]['close'],
                               # 'action': "exit",
                                #'reason': 'stoploss',
                               #}
            #self.execute_signal(signal)
            #logger.info("Close any open trade at the end of testing")
            #self.exit_trade(len(df) - 1, df.iloc[-1]['close'], 'end_of_test')

        logger.info(f"Trade execution completed with {len(self.trades)} trades")
        print(f"Trade execution completed with {len(self.trades)} trades")

        return self.trades, self.equity_curve





    def calculate_performance(self):
        """Calculate and return performance metrics"""
        if not self.trades:
            logger.warning("No trades to calculate performance metrics")
            print("No trades to calculate performance metrics")
            return {
                'total_trades': 0,
                'win_rate': 0,
                'profit_factor': 0,
                'total_return_pct': 0,
                'max_drawdown_pct': 0
            }

        # Calculate win rate
        winning_trades = [t for t in self.trades if t['pnl'] > 0]
        win_rate = len(winning_trades) / len(self.trades)

        # Calculate profit factor
        gross_profit = sum([t['pnl'] for t in self.trades if t['pnl'] > 0])
        gross_loss = abs(sum([t['pnl'] for t in self.trades if t['pnl'] <= 0]))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')

        # Calculate total return
        total_return = (self.balance - self.initial_balance) / self.initial_balance

        # Calculate maximum drawdown
        peak = self.initial_balance
        max_drawdown = 0

        for balance in self.equity_curve:
            if balance > peak:
                peak = balance
            drawdown = (peak - balance) / peak
            max_drawdown = max(max_drawdown, drawdown)

        performance = {
            'total_trades': len(self.trades),
            'winning_trades': len(winning_trades),
            'losing_trades': len(self.trades) - len(winning_trades),
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'total_return': self.balance - self.initial_balance,
            'total_return_pct': total_return * 100,
            'max_drawdown_pct': max_drawdown * 100,
            'final_balance': self.balance
        }

        logger.info(f"Performance metrics: Win rate: {win_rate:.2%}, Profit factor: {profit_factor:.2f}, " +
                     f"Return: {total_return:.2%}, Max drawdown: {max_drawdown:.2%}")
        print(f"Performance metrics: Win rate: {win_rate:.2%}, Profit factor: {profit_factor:.2f}, " +
              f"Return: {total_return:.2%}, Max drawdown: {max_drawdown:.2%}")

        return performance

    def visualize_results(self, start_idx=0, end_idx=None):
        """Visualize backtesting results with trades and SMC patterns"""
        if end_idx is None:
            end_idx = len(self.df)

        # Create figure with subplots
        fig, ax = plt.subplots(figsize=(15, 8))

        # Plot price data
        subset = self.df.iloc[start_idx:end_idx]
        ax.plot(subset.index, subset['close'], label='Close Price', color='black', linewidth=1)

        # Plot FVGs
        for i in range(start_idx, min(end_idx, len(self.df))):
            if self.df.iloc[i].get('bullish_fvg', False) and pd.notna(self.df.iloc[i].get('bullish_fvg_low')):
                fvg_low = self.df.iloc[i]['bullish_fvg_low']
                fvg_high = self.df.iloc[i]['bullish_fvg_high']
                mitigated = self.df.iloc[i].get('bullish_fvg_mitigated', False)
                color = 'lightgreen' if not mitigated else 'darkgreen'
                rect = patches.Rectangle((i-0.5, fvg_low), 1, fvg_high-fvg_low, linewidth=1,
                                        edgecolor=color, facecolor=color, alpha=0.3)
                ax.add_patch(rect)

            if self.df.iloc[i].get('bearish_fvg', False) and pd.notna(self.df.iloc[i].get('bearish_fvg_low')):
                fvg_low = self.df.iloc[i]['bearish_fvg_low']
                fvg_high = self.df.iloc[i]['bearish_fvg_high']
                mitigated = self.df.iloc[i].get('bearish_fvg_mitigated', False)
                color = 'lightcoral' if not mitigated else 'darkred'
                rect = patches.Rectangle((i-0.5, fvg_low), 1, fvg_high-fvg_low, linewidth=1,
                                        edgecolor=color, facecolor=color, alpha=0.3)
                ax.add_patch(rect)

        # Plot BOS and CHoCH
        bos_up_idx = subset[subset['bos_up'] == True].index
        bos_down_idx = subset[subset['bos_down'] == True].index
        choch_up_idx = subset[subset['choch_up'] == True].index
        choch_down_idx = subset[subset['choch_down'] == True].index

        ax.scatter(bos_up_idx, subset.loc[bos_up_idx, 'low'], color='green', marker='^', s=100, label='BOS Up')
        ax.scatter(bos_down_idx, subset.loc[bos_down_idx, 'high'], color='red', marker='v', s=100, label='BOS Down')
        ax.scatter(choch_up_idx, subset.loc[choch_up_idx, 'low'], color='blue', marker='^', s=80, label='CHoCH Up')
        ax.scatter(choch_down_idx, subset.loc[choch_down_idx, 'high'], color='purple', marker='v', s=80, label='CHoCH Down')

        # Plot trades
        for trade in self.trades:
            if start_idx <= trade['entry_index'] < end_idx:
                # Entry point
                color = 'green' if trade['type'] == 'long' else 'red'
                marker = '^' if trade['type'] == 'long' else 'v'
                ax.scatter(trade['entry_index'], trade['entry_price'], color=color, marker=marker, s=120, zorder=5)

                # Exit point
                if trade['exit_index'] < end_idx:
                    color = 'green' if trade['pnl'] > 0 else 'red'
                    ax.scatter(trade['exit_index'], trade['exit_price'], color=color, marker='o', s=120, zorder=5)

                    # Connect entry and exit
                    ax.plot([trade['entry_index'], trade['exit_index']],
                           [trade['entry_price'], trade['exit_price']],
                           color=color, linewidth=1, linestyle='--')

                    # Annotate PnL
                    ax.annotate(f"{trade['pnl']:.2f}",
                              (trade['exit_index'], trade['exit_price']),
                              textcoords="offset points",
                              xytext=(0,10),
                              ha='center')

        ax.set_title('SMC Backtest Results')
        ax.legend(loc='best')
        ax.grid(True, alpha=0.3)

        # Plot equity curve
        fig2, ax2 = plt.subplots(figsize=(15, 5))
        ax2.plot(self.equity_curve, label='Account Balance', color='blue')
        ax2.set_title('Equity Curve')
        ax2.grid(True, alpha=0.3)
        ax2.legend()

        plt.tight_layout()
        return fig, fig2

    def execute_signal(self, signal):
        if signal is None:
            logger.info("No trading signal detected")
            print("No trading signal detected")
            return

        if signal['action'] == 'entry':
            self.execute_entry(signal)
        elif signal['action'] == 'exit':
            self.execute_exit(signal)

    def execute_entry(self, signal):
        side = signal['side']
        price = signal['price']
        stop_loss = signal['stop_loss']
        take_profit = signal['take_profit']

        # Get current time for trade recording
        sast_now = get_sast_time()

        # ... (rest of your execute_entry method remains mostly the same)
        try:
            # Execute order via BitMEX API
            order_side = "Buy" if side == "long" else "Sell"
            order_result = self.api.open_test_position(side=order_side, quantity=self.position_size)

            # Update trading state
            self.in_trade = True
            self.trade_type = side
            self.entry_price = price
            self.stop_loss = stop_loss
            self.take_profit = take_profit

            # Record trade
            trade = {
                'entry_time': sast_now.strftime('%Y-%m-%d %H:%M:%S'),
                'entry_price': price,
                'entry_index': len(self.df) - 1,
                'side': side,
                'position_size': self.position_size,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'risk_amount': self.risk_per_trade * self.current_balance
            }
            self.trades.append(trade)
            self.equity_curve.append(self.current_balance)

        except Exception as e:
            logger.error(f"Error opening {side} position: {str(e)}")
            print(f"Error opening {side} position: {str(e)}")

    def execute_exit(self, signal):
        reason = signal['reason']
        price = signal['price']
        sast_now = get_sast_time()

        try:
            # Close position via BitMEX API
            self.api.close_all_positions()

            # Calculate profit/loss
            if self.trade_type == 'long':
                pnl = (price - self.entry_price) * self.position_size
            else:  # short
                pnl = (self.entry_price - price) * self.position_size

            # Update the latest trade record
            current_trade = self.trades[-1]
            current_trade.update({
                'exit_time': sast_now.strftime('%Y-%m-%d %H:%M:%S'),
                'exit_price': price,
                'exit_index': len(self.df) - 1,
                'exit_reason': reason,
                'pnl': pnl
            })

            # Update balance
            self.current_balance += pnl
            self.equity_curve.append(self.current_balance)

            # Reset trading state
            self.in_trade = False
            self.trade_type = None
            self.entry_price = 0
            self.stop_loss = 0
            self.take_profit = 0
            self.position_size = 0

        except Exception as e:
            logger.error(f"Error closing position: {str(e)}")
            print(f"Error closing position: {str(e)}")


    def run(self, scan_interval=60):
        sast_now = get_sast_time()
        logger.info(f"Starting BitMEXLiveTrader at {sast_now.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Starting BitMEXLiveTrader at {sast_now.strftime('%Y-%m-%d %H:%M:%S')}")

        # Initialize balance
        profile = self.api.get_profile_info()
        self.initial_balance = profile['balance']
        self.current_balance = self.initial_balance
        self.equity_curve = [self.initial_balance]

        try:
            while True:
                sast_now = get_sast_time()
                # Your existing run logic...
                self.get_market_data()
                self.identify_structure()
                self.identify_fvg()
                self.execute_trades()
                self.calculate_performance()

                time.sleep(scan_interval)

        except KeyboardInterrupt:
            # Your existing interrupt handling...
            if self.in_trade:
                self.api.close_all_positions()
                self.in_trade = False

def BitMEXLiveTrader(API_KEY, API_SECRET):
    """
    Main function to run the BitMEXLiveTrader
    """
    # BitMEX API credentials (use your test API key and secret)
    #API_KEY = oAPI_KEY")  # Your test API key
    #API_SECRET = os.getenv("API_SECRET")  # Your test API secret


    try:
        # Call the custom logging configuration function
        #logger = configure_logging()
        print("Current time in SAST:", sast_now.strftime('%Y-%m-%d %H:%M:%S'))
        # Example log calls
        logger.info("This is BitmexSMCLiveTrader version 0.1 ")
        logger.error(f"Current time in SAST:{sast_now.strftime('%Y-%m-%d %H:%M:%S')}")
        # Initialize and run BitMEXLiveTrader
        trader = SMC(
            api_key=API_KEY,
            api_secret=API_SECRET,
            test=True,  # Use testnet
            symbol="SOLUSD",  # Solana/USD
            timeframe="5m",  # 5m candles
            risk_per_trade=0.02  # 2% risk per trade
        )

        # Start trading loop
        trader.run(scan_interval=120)  # Scan every 2 minutes

    except KeyboardInterrupt:
        logger.info("BitMEXLiveTrader stopped by user")
        print("BitMEXLiveTrader stopped by user")
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        print(f"Unexpected error: {str(e)}")


