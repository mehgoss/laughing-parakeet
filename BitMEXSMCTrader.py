# -*- coding: utf-8 -*-
"""CompactBot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1G-0INX6Sh71JGXK0Ve1ZT8BENMvngrPs
"""

#

# -*- coding: utf-8 -*-
import asyncio
import json
import logging
import os
import threading
import time
import pytz
from datetime import datetime, timedelta
from queue import Queue
import sys
import bitmex
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import numpy as np
import pandas as pd
from dotenv import load_dotenv
import yfinance as yf
from BitMEXAPI import BitMEXTestAPI
from TeleLogBot import configure_logging


# Load .env file
load_dotenv()

#Telegram creds
TOKEN =  os.getenv("TOKEN") 
CHAT_ID =  os.getenv("CHAT_ID") 

logger = configure_logging(TOKEN, CHAT_ID)

def get_sast_time():
    utc_now = datetime.utcnow()
    sast = pytz.timezone('Africa/Johannesburg')
    return utc_now.replace(tzinfo=pytz.utc).astimezone(sast)
    

class SMC:
    def __init__(self, api_key="", api_secret="", test=True, symbol="SOL-USD",
                 timeframe="15m", risk_per_trade=0.02, lookback_periods=100):
        """
        Initialize the SMC trading class
        """
        self.api_key = api_key
        self.api_secret = api_secret
        self.test = test
        self.symbol = symbol
        self.timeframe = timeframe
        self.risk_per_trade = risk_per_trade
        self.lookback_periods = lookback_periods

        # Initialize BitMEX API client
        self.api = BitMEXTestAPI(
            api_key=self.api_key,
            api_secret=self.api_secret,
            test=self.test
        )

        # Trading state
        self.initial_balance = 0
        self.current_balance = 0
        self.df = pd.DataFrame()
        self.in_trade = False
        self.entry_price = 0
        self.stop_loss = 0
        self.take_profit = 0
        self.position_size = 0
        self.trade_type = None
        self.trades = []
        self.equity_curve = []

        logger.info(f"BitMEXLiveTrader initialized for {symbol} on {timeframe} timeframe")
    def get_market_data(self):
        """
        Fetch market data from BitMEX API or fallback to yfinance.
        """
        try:
            logger.info(f"Fetching {self.symbol} market data from BitMEX")
            print(f"Fetching {self.symbol} market data from BitMEX")
            data = self.api.get_candle(
                symbol=self.symbol,
                timeframe=self.timeframe
            )
            df = pd.DataFrame(data)
            logger.info(f"Retrieved {len(df)} candles from BitMEX")
            self.df = df
            self.df.columns = [col.lower() for col in self.df.columns]
            self.df['higher_high'] = False
            self.df['lower_low'] = False
            self.df['bos_up'] = False
            self.df['bos_down'] = False
            self.df['choch_up'] = False
            self.df['choch_down'] = False
            self.df['bullish_fvg'] = False
            self.df['bearish_fvg'] = False
            return df
    
        except Exception as e:
            logger.warning(f"Failed to get data from BitMEX API: {str(e)}. Falling back to yfinance.")
            print(f"Failed to get data from BitMEX API: {str(e)}. Falling back to yfinance.")
    
            crypto_ticker = self.symbol if self.symbol.endswith('USD') else f"{self.symbol}-USD"
            sast_now = get_sast_time()
            end_date = sast_now
            start_date = end_date - timedelta(days=2)
    
            try:
                data = yf.download(
                    crypto_ticker,
                    start=start_date.strftime('%Y-%m-%d'),
                    end=end_date.strftime('%Y-%m-%d'),
                    interval=self.timeframe
                )
                logger.info(f"Retrieved {len(data)} candles from yfinance")
                self.df = data
                if not data.empty:
                    if isinstance(self.df.columns, pd.MultiIndex):
                        self.df.columns = [col[0].lower() if col[1] else col[0].lower() for col in self.df.columns]
                    else:
                        self.df.columns = [col.lower() for col in self.df.columns]
                    required_columns = ['open', 'high', 'low', 'close']
                    if all(col in self.df.columns for col in required_columns):
                        self.df['higher_high'] = False
                        self.df['lower_low'] = False
                        self.df['bos_up'] = False
                        self.df['bos_down'] = False
                        self.df['choch_up'] = False
                        self.df['choch_down'] = False
                        self.df['bullish_fvg'] = False
                        self.df['bearish_fvg'] = False
                    else:
                        logger.warning("Missing required columns in yfinance data")
                else:
                    logger.warning("No data retrieved from yfinance")
                return data
            except Exception as e:
                logger.error(f"yfinance fallback failed: {str(e)}")
                return pd.DataFrame()  # Return empty DataFrame on failure
    def identify_structure(self):
        """Identify market structure including highs, lows, BOS and CHoCH"""
        logger.info("Identifying market structure")
        print("Identifying market structure")
        df = self.df

        # Identify Higher Highs and Lower Lows (using a 5-candle lookback)
        window = 5
        for i in range(window, len(df)):
            # Higher High
            if df.iloc[i]['high'] > max(df.iloc[i-window:i]['high']):
                df.loc[df.index[i], 'higher_high'] = True

            # Lower Low
            if df.iloc[i]['low'] < min(df.iloc[i-window:i]['low']):
                df.loc[df.index[i], 'lower_low'] = True

        # Identify Break of Structure (BOS)
        prev_structure_high = df.iloc[0]['high']
        prev_structure_low = df.iloc[0]['low']
        structure_points_high = []
        structure_points_low = []

        for i in range(1, len(df)):
            current_high = df.iloc[i]['high']
            current_low = df.iloc[i]['low']

            # Track significant structure points
            if df.iloc[i]['higher_high']:
                structure_points_high.append((i, current_high))

            if df.iloc[i]['lower_low']:
                structure_points_low.append((i, current_low))

            # BOS Up: Price breaks above recent structure high
            if len(structure_points_high) >= 2:
                last_high_idx, last_high = structure_points_high[-1]
                prev_high_idx, prev_high = structure_points_high[-2]

                if current_low > prev_high and i > last_high_idx + 1:
                    df.loc[df.index[i], 'bos_up'] = True
                    #logger.info(f"Bullish BOS detected at index {df.iloc[i]['close']:.2f}, price: {current_low}")
                    print(f"Bullish BOS detected at index {i}, price: {current_low}")

            # BOS Down: Price breaks below recent structure low
            if len(structure_points_low) >= 2:
                last_low_idx, last_low = structure_points_low[-1]
                prev_low_idx, prev_low = structure_points_low[-2]

                if current_high < prev_low and i > last_low_idx + 1:
                    df.loc[df.index[i], 'bos_down'] = True
                   #logger.info(f"Bearish BOS detected at index {df.iloc[i]['close']:.2f}, price: {current_high}")
                    print(f"Bearish BOS detected at index {i}, price: {current_high}")

        # Identify Change of Character (CHoCH)
        for i in range(window+1, len(df)):
            # Bullish CHoCH: After BOS up, creates higher low
            if df.iloc[i-1]['bos_up']:
                recent_lows = df.iloc[i-window:i]['low'].tolist()
                if min(recent_lows[:-1]) < recent_lows[-1]:
                    df.loc[df.index[i], 'choch_up'] = True
                    #logger.info(f"Bullish CHoCH detected at index {df.iloc[i]['close']:.2f},  price: {current_high}")
                    print(f"Bullish CHoCH detected at index {i},  price: {current_high}")

            # Bearish CHoCH: After BOS down, creates lower high
            if df.iloc[i-1]['bos_down']:
                recent_highs = df.iloc[i-window:i]['high'].tolist()
                if max(recent_highs[:-1]) > recent_highs[-1]:
                    df.loc[df.index[i], 'choch_down'] = True
                    #logger.info(f"Bearish CHoCH detected at index {df.iloc[i]['close']:2f},  price: {current_high}")
                    print(f"Bearish CHoCH detected at index {i}")
        logger.info("End of Identifying market structure")
        return df

    def identify_fvg(self):
        """Identify Fair Value Gaps (FVGs)"""
        logger.info("Identifying Fair Value Gaps")
        print("Identifying Fair Value Gaps")
        df = self.df

        # Create separate columns for FVG values to avoid tuple storage issues
        if 'bullish_fvg_low' not in df.columns:
            df['bullish_fvg_low'] = np.nan
            df['bullish_fvg_high'] = np.nan
            df['bullish_fvg_sl_index'] = np.nan

        if 'bearish_fvg_low' not in df.columns:
            df['bearish_fvg_low'] = np.nan
            df['bearish_fvg_high'] = np.nan
            df['bearish_fvg_sl_index'] = np.nan

        # Add mitigation tracking columns
        if 'bullish_fvg_mitigated' not in df.columns:
            df['bullish_fvg_mitigated'] = False

        if 'bearish_fvg_mitigated' not in df.columns:
            df['bearish_fvg_mitigated'] = False

        for i in range(2, len(df)):
            # Bullish FVG: Previous candle's low > Current candle's high
            if df.iloc[i-2]['low'] > df.iloc[i]['high']:
                # Check Gann Box (0-0.5 range for bullish FVGs)
                high_point = df.iloc[i-2]['high']
                low_point = df.iloc[i]['low']
                price_range = high_point - low_point
                fvg_low = df.iloc[i]['high']
                fvg_high = df.iloc[i-2]['low']

                # Calculate relative position in Gann Box (0 to 1)
                if price_range > 0:
                    relative_pos = (fvg_high - low_point) / price_range

                    # Only mark valid FVGs within 0-0.5 Gann range
                    if 0 <= relative_pos <= 0.5:
                        df.loc[df.index[i], 'bullish_fvg'] = True
                        # Store FVG values in separate columns
                        df.loc[df.index[i], 'bullish_fvg_low'] = fvg_low
                        df.loc[df.index[i], 'bullish_fvg_high'] = fvg_high
                        df.loc[df.index[i], 'bullish_fvg_sl_index'] = i

                        #logger.info(f"Bullish FVG detected at index {df.iloc[i]['close']:.2f}, range: {fvg_low}-{fvg_high}")
                        print(f"Bullish FVG detected at index {i}, range: {fvg_low}-{fvg_high}")

            # Bearish FVG: Previous candle's high < Current candle's low
            if df.iloc[i-2]['high'] < df.iloc[i]['low']:
                # Check Gann Box (0.5-1 range for bearish FVGs)
                high_point = df.iloc[i]['high']
                low_point = df.iloc[i-2]['low']
                price_range = high_point - low_point
                fvg_low = df.iloc[i-2]['high']
                fvg_high = df.iloc[i]['low']

                # Calculate relative position in Gann Box (0 to 1)
                if price_range > 0:
                    relative_pos = (fvg_high - low_point) / price_range

                    # Only mark valid FVGs within 0.5-1 Gann range
                    if 0.5 <= relative_pos <= 1:
                        df.loc[df.index[i], 'bearish_fvg'] = True
                        # Store FVG values in separate columns
                        df.loc[df.index[i], 'bearish_fvg_low'] = fvg_low
                        df.loc[df.index[i], 'bearish_fvg_high'] = fvg_high
                        df.loc[df.index[i], 'bearish_fvg_sl_index'] = i

                        #logger.info(f"Bearish FVG detected at index {df.iloc[i]['close']:.2f}, range: {fvg_low}-{fvg_high}")
                        print(f"Bearish FVG detected at index {df.iloc[i]['close']}, range: {fvg_low}-{fvg_high}")
        logger.info("End of Identifying Fair Value Gaps")
        return df

    def check_fvg_mitigation(self, current_idx):
        """Check if any previously identified FVGs have been mitigated"""
        #logger.info("Check if any previously identified FVGs have been mitigated")
        df = self.df

        # Loop through all previous candles
        #check if curent candle is on unmitigated and is ohkay to wick out of fvg but dont close above or below the fvg
        # 
        
        for i in range(current_idx):
            # Check if the candle had a bullish FVG
            if df.iloc[i].get('bullish_fvg', False) and pd.notna(df.iloc[i].get('bullish_fvg_low')):
                fvg_low = df.iloc[i]['bullish_fvg_low']
                fvg_high = df.iloc[i]['bullish_fvg_high']

                # Check if price revisited the FVG area
                for j in range(i+1, current_idx+1):
                    if df.iloc[j]['low'] <= fvg_high and df.iloc[j]['high'] >= fvg_low:
                        # FVG has been mitigated
                        df.loc[df.index[i], 'bullish_fvg_mitigated'] = True
                        #logger.info(f"Bullish FVG at index {df.iloc[i]['close']:.2f} has been mitigated at index {df.iloc[j]['close']:.2f}")
                        print(f"Bullish FVG at index {i} has been mitigated at index {j}")
                        break

            # Check if the candle had a bearish FVG
            if df.iloc[i].get('bearish_fvg', False) and pd.notna(df.iloc[i].get('bearish_fvg_low')):
                fvg_low = df.iloc[i]['bearish_fvg_low']
                fvg_high = df.iloc[i]['bearish_fvg_high']

                # Check if price revisited the FVG area
                for j in range(i+1, current_idx+1):
                    if df.iloc[j]['low'] <= fvg_high and df.iloc[j]['high'] >= fvg_low:
                        # FVG has been mitigated
                        df.loc[df.index[i], 'bearish_fvg_mitigated'] = True
                        #logger.info(f"Bearish FVG at index {df.iloc[i]['close']: 2f} has been mitigated at index {df.iloc[j]['close']}:.2f")
                        print(f"Bearish FVG at index {df.iloc[i]['close']:.2f} has been mitigated at index {df.iloc[j]['close']:2f}")
                        break

        return df
            
    def execute_trades(self):
        """
        Execute trades based on SMC signals for live trading.
        - Analyzes the last 4 hours and the current candle for valid entries.
        - Uses unmitigated FVGs for trade setups.
        - Updates balance dynamically and supports one trade at a time.
        - Returns early if no signal is detected when not in a trade.
        """
        logger.info("Starting live trade execution")
        print("Starting live trade execution")
        df = self.df
    
        # Ensure we have enough data (at least 4 hours worth)
        candles_per_hour = 4 if self.timeframe == "15m" else 1 if self.timeframe == "5m" else 1
        min_candles = candles_per_hour * 4  # 4 hours of data
        if len(df) < min_candles:
            logger.warning(f"Not enough data: {len(df)} candles available, need at least {min_candles}")
            print(f"Not enough data: {len(df)} candles available, need at least {min_candles}")
            return [], self.equity_curve
    
        # Get the current candle (latest) and the last 4 hours of data
        current_candle_idx = len(df) - 1
        current_price = df.iloc[current_candle_idx]['close']
        lookback_start_idx = max(0, current_candle_idx - min_candles)
    
        # Update FVG mitigation status up to the current candle
        self.check_fvg_mitigation(current_candle_idx)
    
        # Check if we're currently in a trade
        if self.in_trade:
            # Monitor existing trade
            if self.trade_type == 'long':
                if df.iloc[current_candle_idx]['low'] <= self.stop_loss:
                    self.execute_signal({
                        'price': self.stop_loss,
                        'action': "exit",
                        'reason': 'stoploss'
                    })
                    logger.info(f"Long trade stopped out at {self.stop_loss}")
                    print(f"Long trade stopped out at {self.stop_loss}")
    
                elif df.iloc[current_candle_idx]['high'] >= self.take_profit:
                    self.execute_signal({
                        'price': self.take_profit,
                        'action': "exit",
                        'reason': 'takeprofit'
                    })
                    logger.info(f"Long trade took profit at {self.take_profit}")
                    print(f"Long trade took profit at {self.take_profit}")
    
            elif self.trade_type == 'short':
                if df.iloc[current_candle_idx]['high'] >= self.stop_loss:
                    self.execute_signal({
                        'price': self.stop_loss,
                        'action': "exit",
                        'reason': 'stoploss'
                    })
                    logger.info(f"Short trade stopped out at {self.stop_loss}")
                    print(f"Short trade stopped out at {self.stop_loss}")
    
                elif df.iloc[current_candle_idx]['low'] <= self.take_profit:
                    self.execute_signal({
                        'price': self.take_profit,
                        'action': "exit",
                        'reason': 'takeprofit'
                    })
                    logger.info(f"Short trade took profit at {self.take_profit}")
                    print(f"Short trade took profit at {self.take_profit}")
    
        # Check for new trade setups if not in a trade
        else:
            signal_detected = False
    
            # Bullish setup: BOS up + CHoCH up + unmitigated bullish FVG
            if df.iloc[current_candle_idx - 1]['bos_up'] and df.iloc[current_candle_idx]['choch_up']:
                # Look back over the last 4 hours for unmitigated bullish FVGs
                for j in range(lookback_start_idx, current_candle_idx):
                    if df.iloc[j].get('bullish_fvg', False) and not df.iloc[j].get('bullish_fvg_mitigated', False):
                        fvg_low = df.iloc[j]['bullish_fvg_low']
                        fvg_high = df.iloc[j]['bullish_fvg_high']
                        sl_idx = int(df.iloc[j]['bullish_fvg_sl_index'])
    
                        # Check if current price is within or just above the FVG (allow wicking)
                        if fvg_low <= current_price <= fvg_high or \
                           (current_price > fvg_high and df.iloc[current_candle_idx]['low'] >= fvg_low):
                            # Calculate position size based on risk
                            stop_loss = df.iloc[sl_idx]['low']
                            risk = current_price - stop_loss
                            if risk <= 0:
                                continue  # Invalid stop loss
                            risk_amount = self.current_balance * self.risk_per_trade
                            self.position_size = risk_amount / risk
                            take_profit = current_price + (risk * 2)  # 2:1 risk-reward
    
                            signal = {
                                'action': 'entry',
                                'side': 'long',
                                'price': current_price,
                                'stop_loss': stop_loss,
                                'take_profit': take_profit
                            }
                            self.execute_signal(signal)
                            logger.info(f"Entered long trade at {current_price}, SL: {stop_loss}, TP: {take_profit}")
                            print(f"Entered long trade at {current_price}, SL: {stop_loss}, TP: {take_profit}")
                            signal_detected = True
                            break  # Only take one trade at a time
    
            # Bearish setup: BOS down + CHoCH down + unmitigated bearish FVG
            elif df.iloc[current_candle_idx - 1]['bos_down'] and df.iloc[current_candle_idx]['choch_down']:
                # Look back over the last 4 hours for unmitigated bearish FVGs
                for j in range(lookback_start_idx, current_candle_idx):
                    if df.iloc[j].get('bearish_fvg', False) and not df.iloc[j].get('bearish_fvg_mitigated', False):
                        fvg_low = df.iloc[j]['bearish_fvg_low']
                        fvg_high = df.iloc[j]['bearish_fvg_high']
                        sl_idx = int(df.iloc[j]['bearish_fvg_sl_index'])
    
                        # Check if current price is within or just below the FVG (allow wicking)
                        if fvg_low <= current_price <= fvg_high or \
                           (current_price < fvg_low and df.iloc[current_candle_idx]['high'] <= fvg_high):
                            # Calculate position size based on risk
                            stop_loss = df.iloc[sl_idx]['high']
                            risk = stop_loss - current_price
                            if risk <= 0:
                                continue  # Invalid stop loss
                            risk_amount = self.current_balance * self.risk_per_trade
                            self.position_size = risk_amount / risk
                            take_profit = current_price - (risk * 2)  # 2:1 risk-reward
    
                            signal = {
                                'action': 'entry',
                                'side': 'short',
                                'price': current_price,
                                'stop_loss': stop_loss,
                                'take_profit': take_profit
                            }
                            self.execute_signal(signal)
                            logger.info(f"Entered short trade at {current_price}, SL: {stop_loss}, TP: {take_profit}")
                            print(f"Entered short trade at {current_price}, SL: {stop_loss}, TP: {take_profit}")
                            signal_detected = True
                            break  # Only take one trade at a time
    
            # If no signal detected, return early
            if not signal_detected:
                logger.info("No trading signal detected, exiting trade check")
                print("No trading signal detected, exiting trade check")
                return self.trades, self.equity_curve
    
        logger.info(f"Live trade check completed. In trade: {self.in_trade}, Total trades: {len(self.trades)}")
        print(f"Live trade check completed. In trade: {self.in_trade}, Total trades: {len(self.trades)}")
        return self.trades, self.equity_curve





    def calculate_performance(self):
        """Calculate and return performance metrics"""
        if not self.trades:
            logger.warning("No trades to calculate performance metrics")
            print("No trades to calculate performance metrics")
            return {
                'total_trades': 0,
                'win_rate': 0,
                'profit_factor': 0,
                'total_return_pct': 0,
                'max_drawdown_pct': 0
            }

        # Calculate win rate
        winning_trades = [t for t in self.trades if t['pnl'] > 0]
        win_rate = len(winning_trades) / len(self.trades)

        # Calculate profit factor
        gross_profit = sum([t['pnl'] for t in self.trades if t['pnl'] > 0])
        gross_loss = abs(sum([t['pnl'] for t in self.trades if t['pnl'] <= 0]))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')

        # Calculate total return
        total_return = (self.current_balance - self.initial_balance) / self.initial_balancex

        # Calculate maximum drawdown
        peak = self.initial_balance
        max_drawdown = 0

        for balance in self.equity_curve:
            if balance > peak:
                peak = balance
            drawdown = (peak - balance) / peak
            max_drawdown = max(max_drawdown, drawdown)

        performance = {
            'total_trades': len(self.trades),
            'winning_trades': len(winning_trades),
            'losing_trades': len(self.trades) - len(winning_trades),
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'total_return': self.balance - self.initial_balance,
            'total_return_pct': total_return * 100,
            'max_drawdown_pct': max_drawdown * 100,
            'final_balance': self.current_balance
        }

        logger.info(f"Performance metrics: Win rate: {win_rate:.2%}, Profit factor: {profit_factor:.2f}, " +
                     f"Return: {total_return:.2%}, Max drawdown: {max_drawdown:.2%}")
        print(f"Performance metrics: Win rate: {win_rate:.2%}, Profit factor: {profit_factor:.2f}, " +
              f"Return: {total_return:.2%}, Max drawdown: {max_drawdown:.2%}")

        return performance

    def visualize_results(self, start_idx=0, end_idx=None):
        """Visualize backtesting results with trades and SMC patterns"""
        if end_idx is None:
            end_idx = len(self.df)

        # Create figure with subplots
        fig, ax = plt.subplots(figsize=(15, 8))

        # Plot price data
        subset = self.df.iloc[start_idx:end_idx]
        ax.plot(subset.index, subset['close'], label='Close Price', color='black', linewidth=1)

        # Plot FVGs
        for i in range(start_idx, min(end_idx, len(self.df))):
            if self.df.iloc[i].get('bullish_fvg', False) and pd.notna(self.df.iloc[i].get('bullish_fvg_low')):
                fvg_low = self.df.iloc[i]['bullish_fvg_low']
                fvg_high = self.df.iloc[i]['bullish_fvg_high']
                mitigated = self.df.iloc[i].get('bullish_fvg_mitigated', False)
                color = 'lightgreen' if not mitigated else 'darkgreen'
                rect = patches.Rectangle((i-0.5, fvg_low), 1, fvg_high-fvg_low, linewidth=1,
                                        edgecolor=color, facecolor=color, alpha=0.3)
                ax.add_patch(rect)

            if self.df.iloc[i].get('bearish_fvg', False) and pd.notna(self.df.iloc[i].get('bearish_fvg_low')):
                fvg_low = self.df.iloc[i]['bearish_fvg_low']
                fvg_high = self.df.iloc[i]['bearish_fvg_high']
                mitigated = self.df.iloc[i].get('bearish_fvg_mitigated', False)
                color = 'lightcoral' if not mitigated else 'darkred'
                rect = patches.Rectangle((i-0.5, fvg_low), 1, fvg_high-fvg_low, linewidth=1,
                                        edgecolor=color, facecolor=color, alpha=0.3)
                ax.add_patch(rect)

        # Plot BOS and CHoCH
        bos_up_idx = subset[subset['bos_up'] == True].index
        bos_down_idx = subset[subset['bos_down'] == True].index
        choch_up_idx = subset[subset['choch_up'] == True].index
        choch_down_idx = subset[subset['choch_down'] == True].index

        ax.scatter(bos_up_idx, subset.loc[bos_up_idx, 'low'], color='green', marker='^', s=100, label='BOS Up')
        ax.scatter(bos_down_idx, subset.loc[bos_down_idx, 'high'], color='red', marker='v', s=100, label='BOS Down')
        ax.scatter(choch_up_idx, subset.loc[choch_up_idx, 'low'], color='blue', marker='^', s=80, label='CHoCH Up')
        ax.scatter(choch_down_idx, subset.loc[choch_down_idx, 'high'], color='purple', marker='v', s=80, label='CHoCH Down')

        # Plot trades
        for trade in self.trades:
            if start_idx <= trade['entry_index'] < end_idx:
                # Entry point
                color = 'green' if trade['type'] == 'long' else 'red'
                marker = '^' if trade['type'] == 'long' else 'v'
                ax.scatter(trade['entry_index'], trade['entry_price'], color=color, marker=marker, s=120, zorder=5)

                # Exit point
                if trade['exit_index'] < end_idx:
                    color = 'green' if trade['pnl'] > 0 else 'red'
                    ax.scatter(trade['exit_index'], trade['exit_price'], color=color, marker='o', s=120, zorder=5)

                    # Connect entry and exit
                    ax.plot([trade['entry_index'], trade['exit_index']],
                           [trade['entry_price'], trade['exit_price']],
                           color=color, linewidth=1, linestyle='--')

                    # Annotate PnL
                    ax.annotate(f"{trade['pnl']:.2f}",
                              (trade['exit_index'], trade['exit_price']),
                              textcoords="offset points",
                              xytext=(0,10),
                              ha='center')

        ax.set_title('SMC Backtest Results')
        ax.legend(loc='best')
        ax.grid(True, alpha=0.3)

        # Plot equity curve
        fig2, ax2 = plt.subplots(figsize=(15, 5))
        ax2.plot(self.equity_curve, label='Account Balance', color='blue')
        ax2.set_title('Equity Curve')
        ax2.grid(True, alpha=0.3)
        ax2.legend()

        plt.tight_layout()
        return fig, fig2

    def execute_signal(self, signal):
        if signal is None:
            logger.info("No trading signal detected")
            print("No trading signal detected")
            return

        if signal['action'] == 'entry':
            self.execute_entry(signal)
        elif signal['action'] == 'exit':
            self.execute_exit(signal)

    def execute_entry(self, signal):
        side = signal['side']
        price = signal['price']
        stop_loss = signal['stop_loss']
        take_profit = signal['take_profit']

        # Get current time for trade recording
        sast_now = get_sast_time()

        # ... (rest of your execute_entry method remains mostly the same)
        try:
            # Execute order via BitMEX API
            order_side = "Buy" if side == "long" else "Sell"
            order_result = self.api.open_test_position(side=order_side, quantity=self.position_size)

            # Update trading state
            self.in_trade = True
            self.trade_type = side
            self.entry_price = price
            self.stop_loss = stop_loss
            self.take_profit = take_profit

            # Record trade
            trade = {
                'entry_time': sast_now.strftime('%Y-%m-%d %H:%M:%S'),
                'entry_price': price,
                'entry_index': len(self.df) - 1,
                'side': side,
                'position_size': self.position_size,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'risk_amount': self.risk_per_trade * self.current_balance
            }
            self.trades.append(trade)
            self.equity_curve.append(self.current_balance)

        except Exception as e:
            logger.error(f"Error opening {side} position: {str(e)}")
            print(f"Error opening {side} position: {str(e)}")

    def execute_exit(self, signal):
        reason = signal['reason']
        price = signal['price']
        sast_now = get_sast_time()

        try:
            # Close position via BitMEX API
            self.api.close_all_positions()

            # Calculate profit/loss
            if self.trade_type == 'long':
                pnl = (price - self.entry_price) * self.position_size
            else:  # short
                pnl = (self.entry_price - price) * self.position_size

            # Update the latest trade record
            current_trade = self.trades[-1]
            current_trade.update({
                'exit_time': sast_now.strftime('%Y-%m-%d %H:%M:%S'),
                'exit_price': price,
                'exit_index': len(self.df) - 1,
                'exit_reason': reason,
                'pnl': pnl
            })

            # Update balance
            self.current_balance += pnl
            self.equity_curve.append(self.current_balance)

            # Reset trading state
            self.in_trade = False
            self.trade_type = None
            self.entry_price = 0
            self.stop_loss = 0
            self.take_profit = 0
            self.position_size = 0

        except Exception as e:
            logger.error(f"Error closing position: {str(e)}")
            print(f"Error closing position: {str(e)}")
    
    def run(self, scan_interval=60):
        """
        Main loop for live trading with the SMC strategy.
        - Fetches real-time market data, processes trades, and visualizes results.
        - Syncs balance with the API and handles interruptions gracefully.
        - Runs indefinitely until interrupted, checking for trades every scan_interval seconds.
        """
        sast_now = get_sast_time()
        logger.info(f"Starting BitMEXLiveTrader at {sast_now.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Starting BitMEXLiveTrader at {sast_now.strftime('%Y-%m-%d %H:%M:%S')}")
    
        # Initialize balance from API
        try:
            profile = self.api.get_profile_info()
            
            self.initial_balance = self.api.wallet_balance_usd
            self.current_balance = self.initial_balance
            self.equity_curve = [self.initial_balance]
            logger.info(f"Initial balance set to {self.initial_balance}")
        except Exception as e:
            logger.error(f"Failed to initialize balance: {str(e)}")
            print(f"Failed to initialize balance: {str(e)}")
            return  # Exit if we can't get the initial balance
    
        # Main trading loop
        try:
            while True:
                sast_now = get_sast_time()
                logger.info(f"New scan started at {sast_now.strftime('%Y-%m-%d %H:%M:%S')}")
                print(f"New scan started at {sast_now.strftime('%Y-%m-%d %H:%M:%S')}")
    
                # Step 1: Fetch latest market data
                self.get_market_data()
                if self.df.empty or len(self.df) < 16:  # Minimum 4 hours of 15m candles or equivalent
                    logger.warning(f"Insufficient data: {len(self.df)} candles retrieved")
                    print(f"Insufficient data: {len(self.df)} candles retrieved")
                    time.sleep(scan_interval)
                    continue
    
                # Step 2: Analyze market structure and FVGs
                self.identify_structure()
                self.identify_fvg()
    
                # Step 3: Execute trades based on current conditions
                trades, equity_curve = self.execute_trades()
                if not trades and not self.in_trade:
                    logger.info("No trades executed or in progress during this scan")
                else:
                    logger.info(f"Trades executed or monitored. Total trades: {len(self.trades)}")
    
                # Step 4: Sync balance with API (post-trade)
                try:
                    profile = self.api.get_profile_info()
                    api_balance = profile['balance']
                    if abs(api_balance - self.current_balance) > 0.01:  # Small tolerance
                        logger.info(f"Balance updated from API: {self.current_balance} -> {api_balance}")
                        self.current_balance = api_balance
                        self.equity_curve.append(self.current_balance)
                except Exception as e:
                    logger.warning(f"Failed to sync balance with API: {str(e)}")
                    print(f"Failed to sync balance with API: {str(e)}")
    
                # Step 5: Calculate and log performance metrics
                performance = self.calculate_performance()
                logger.info(f"Performance snapshot: {performance}")
    
                # Step 6: Visualize results (optional, can be toggled or run periodically)
                if self.trades:  # Only visualize if there are trades to show
                    try:
                        # Show last 4 hours of data (adjust based on timeframe: 16 for 15m, 48 for 5m)
                        lookback_candles = 16 if self.timeframe == "15m" else 48 if self.timeframe == "5m" else 4
                        fig, fig2 = self.visualize_results(start_idx=max(0, len(self.df) - lookback_candles))
                        plt.show()  # Displays charts (non-blocking in some environments)
                        plt.close(fig)
                        plt.close(fig2)
                    except Exception as e:
                        logger.warning(f"Visualization failed: {str(e)}")
    
                # Wait for the next scan
                logger.info(f"Waiting {scan_interval} seconds for next scan...")
                time.sleep(scan_interval)
    
        except KeyboardInterrupt:
            logger.info("Trading loop stopped by user")
            print("Trading loop stopped by user")
            if self.in_trade:
                try:
                    self.api.close_all_positions()
                    logger.info("All open positions closed due to interruption")
                    print("All open positions closed due to interruption")
                except Exception as e:
                    logger.error(f"Failed to close positions on exit: {str(e)}")
                    print(f"Failed to close positions on exit: {str(e)}")
            
            # Final performance report
            final_performance = self.calculate_performance()
            logger.info(f"Final performance metrics: {final_performance}")
            print(f"Final performance metrics: {final_performance}")
    
        except Exception as e:
            logger.error(f"Unexpected error in trading loop: {str(e)}")
            print(f"Unexpected error in trading loop: {str(e)}")
            if self.in_trade:
                try:
                    self.api.close_all_positions()
                    logger.info("Emergency closure of all positions")
                except Exception as e:
                    logger.error(f"Failed to close positions during error handling: {str(e)}")
    
    
    
def BitMEXLiveTrader(API_KEY, API_SECRET):
    """
    Main function to run the BitMEXLiveTrader
    """
    # BitMEX API credentials (use your test API key and secret)
    #API_KEY = os.getenv("API_KEY")  # Your test API key
    #API_SECRET = os.getenv("API_SECRET")  # Your test API secret


    try:
        
        print("Current time in SAST:", get_sast_time().strftime('%Y-%m-%d %H:%M:%S'))
        # Example log calls
        logger.info("BitmexSMCLiveTrader version 0.1 ")
        logger.info(f"Current time in SAST: {get_sast_time().strftime('%Y-%m-%d %H:%M:%S')}")
        # Initialize and run BitMEXLiveTrader
        api= BitMEXTestAPI(
            api_key=API_KEY,
            api_secret=API_SECRET,
            test='test'
        )
        trader = SMC(
            api_key=API_KEY,
            api_secret=API_SECRET,
            test=True,  # Use testnet
            symbol="SOL-USD",  # Solana/USD
            timeframe="5m",  # 5m candles
            risk_per_trade=0.02  # 2% risk per trade
            )
         
        api.run_test_sequence()
        logger.info("Welcome to BitmexSMCLiveTrader version 0.1🥺🥺\n - Bitmax Api Looks good to go👍👍👍\n -Start Trading with Smart Money Concept Strategy🤲")
        # Start trading loop
        trader.run(scan_interval=120)  # Scan every 2 minutes

    except KeyboardInterrupt:
        logger.info("BitMEXLiveTrader stopped by user")
        print("BitMEXLiveTrader stopped by user")
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        print(f"Unexpected error: {str(e)}")


